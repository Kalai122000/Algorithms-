// Belmman-Ford is an SSSP (single source shortest path) algorthim
// - When the algorithm finishes, the shortest distance from source to all other vertex's in the graph will be known
// - Bellman-Ford alsow works for graphs with negative edge weights and can detect negative cycles if they exist
// - However, if there are only positive edge weights one should use Dijkstra's instead since it has a better runtime
// Bellman-ford vs. Dijkstra's:
// - Both algorithms are based on the principle of relaxation, in which an approximation to the shortest path
// is gradually replaced by more accurate values until the optimal solution is reached.
// - However, Dijkstra's uses a priority queue to greedily select the closest vertex that has not yet been 
// processed and performs this relaxation to all of its outgoing edges. In contrast, Bellman-ford simply
// relaxes ALL of the edges V-1 times. On each iteration, the number of vertices with correctly calculated distances 
// grows, from which it follows that eventually all vertices will have their correct distances
// Total Runtime: O(VE)

import java.util.*;

public class BellmanFord {
    
    static class Edge {
        int source;
        int destination;
        int weight;
        
        public Edge(int source, int destination, int weight) {
            this.source = source;
            this.destination = destination;
            this.weight = weight;
        }
    }
    
    public static void bellmanFord(List<Edge> edges, int vertexCount, int source) {

        int[] distances = new int[vertexCount];
        int[] predecessors = new int[vertexCount];

        Arrays.fill(distances, Integer.MAX_VALUE); // All distances set to infinity
        Arrays.fill(predecessors, -1);            // All predecessors set to null (-1)
        distances[source] = 0;                    // Distance from source to itself is 0

        for (int i = 1; i < vertexCount; i++) {
            for (Edge edge : edges) {
                int u = edge.source;
                int v = edge.destination;
                int weight = edge.weight;

                if (distances[u] != Integer.MAX_VALUE && 
                    distances[u] + weight < distances[v]) {
                    distances[v] = distances[u] + weight;
                    predecessors[v] = u;
                }
            }
        }

        for (Edge edge : edges) {
            int u = edge.source;
            int v = edge.destination;
            int weight = edge.weight;
            
            if (distances[u] != Integer.MAX_VALUE && 
                distances[u] + weight < distances[v]) {
                System.out.println("Graph contains a negative weight cycle");
                return;
            }
        }
        System.out.println("Vertex\tDistance\tPredecessor");
        for (int i = 0; i < vertexCount; i++) {
            System.out.println(i + "\t" + (distances[i] == Integer.MAX_VALUE ? "INF" : distances[i]) +  "\t\t" + predecessors[i]);
        }
    }
    
    public static void main(String[] args) {
        List<Edge> edges = new ArrayList<>();
        edges.add(new Edge(0, 1, 4));
        edges.add(new Edge(0, 2, 5));
        edges.add(new Edge(1, 2, -3));
        edges.add(new Edge(2, 3, 4));
        edges.add(new Edge(3, 1, -2));
        
        int vertexCount = 4; // Number of vertices in the graph
        int source = 0;      // Source vertex
        
        bellmanFord(edges, vertexCount, source);
    }
}
